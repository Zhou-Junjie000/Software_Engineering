package com.xlf.common.easyexcel;


import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.alibaba.excel.annotation.ExcelProperty;
import com.alibaba.excel.context.AnalysisContext;
import com.alibaba.excel.event.AnalysisEventListener;
import com.alibaba.excel.exception.ExcelAnalysisException;
import com.alibaba.excel.util.StringUtils;
import com.xlf.modules.dataMaintenance.entity.SupportEntniy;

import cn.hutool.core.util.StrUtil;
import lombok.Data;
import lombok.EqualsAndHashCode;

/**
 * 
 * @Description:easyExcel监听器
 * @author: songpeng 
 * @date: date{time} （日期）
 */
@Data
@EqualsAndHashCode(callSuper=false)
public class EasyExcelListener <T>  extends AnalysisEventListener<T> {

    //成功结果集
    private List<T> successList = new ArrayList<>();
    
    private List<SupportEntniy> insertList = new ArrayList<>();

    //失败结果集
    private List<ExcelCheckErrDto<T>> errList = new ArrayList<>();

    //处理逻辑service
    private ExcelCheckManager<T> excelCheckManager;

    private List<T> list = new ArrayList<>();

    //excel对象的反射类
    private Class<T> clazz;

    public EasyExcelListener(ExcelCheckManager<T> excelCheckManager){
        this.excelCheckManager = excelCheckManager;
    }

    public EasyExcelListener(ExcelCheckManager<T> excelCheckManager,Class<T> clazz){
        this.excelCheckManager = excelCheckManager;
        this.clazz = clazz;
    }
    @SuppressWarnings({ "unchecked", "rawtypes", "deprecation" })
    @Override
    public void invoke(T t, AnalysisContext analysisContext) {
    	//自定义某个sheet不读
    	SheetIgnore sheetIgnore = clazz.getAnnotation(SheetIgnore.class);
        if(sheetIgnore != null && StrUtil.equalsIgnoreCase(analysisContext.getCurrentSheet().getSheetName(), sheetIgnore.value())) return;
        String errMsg = "";
        try {
            Class cla = (Class) t.getClass();
            Field[] fs = cla.getDeclaredFields();
            for(int i = 0 ; i < fs.length; i++){
                Field f = fs[i];
                f.setAccessible(true);
                if (StrUtil.equalsIgnoreCase(f.getName().toString(), "rowIndex")) {
                   f.set(t, analysisContext.readRowHolder().getRowIndex()) ;        //给属性设值
                }
            }
            //根据excel数据实体中的javax.validation + 正则表达式来校验excel数据
            errMsg = EasyExcelValiHelper.validateEntity(t);
        } catch (NoSuchFieldException e) {
            errMsg = "解析数据出错";
            e.printStackTrace();
        }catch (IllegalArgumentException e) {
			e.printStackTrace();
		} catch (IllegalAccessException e) {
			e.printStackTrace();
		}
        if (!StringUtils.isEmpty(errMsg)){
        	errMsg = "页签【"+analysisContext.getCurrentSheet().getSheetName()+"】@"+errMsg;
            ExcelCheckErrDto excelCheckErrDto = new ExcelCheckErrDto(t, errMsg);
            errList.add(excelCheckErrDto);
        }else{
            list.add(t);
        }
        //每1000条处理一次
        if (list.size() > 1000){
            //校验
            ExcelCheckResult result = excelCheckManager.checkImportExcel(list,analysisContext.getCurrentSheet().getSheetName());
            successList.addAll(result.getSuccessDtos());
            errList.addAll(result.getErrDtos());
            insertList.addAll(result.getInsertList());
            list.clear();
        }
    }

    //所有数据解析完成了 都会来调用
    @SuppressWarnings({ "unchecked", "rawtypes", "deprecation" })
	@Override
    public void doAfterAllAnalysed(AnalysisContext analysisContext) {
        ExcelCheckResult result = excelCheckManager.checkImportExcel(list,analysisContext.getCurrentSheet().getSheetName());

        successList.addAll(result.getSuccessDtos());
        errList.addAll(result.getErrDtos());
        insertList.addAll(result.getInsertList());
        list.clear();
    }


    /**
      * @description: 校验excel头部格式，必须完全匹配
      * @param headMap 传入excel的头部（第一行数据）数据的index,name
      * @param context
      * @throws
      * @return void
      * @author zhy
      * @date 2019/12/24 19:27
      */
    @SuppressWarnings("deprecation")
	@Override
    public void invokeHeadMap(Map<Integer, String> headMap, AnalysisContext context) {
        super.invokeHeadMap(headMap, context);
      //自定义某个sheet不校验
        SheetIgnore sheetIgnore = clazz.getAnnotation(SheetIgnore.class);
        if(sheetIgnore != null && StrUtil.equalsIgnoreCase(context.getCurrentSheet().getSheetName(), sheetIgnore.value())) return;
        if (clazz != null){
            try {
                Map<Integer, String> indexNameMap = getIndexNameMap(clazz);
                Set<Integer> keySet = indexNameMap.keySet();
                for (Integer key : keySet) {
                    if (StringUtils.isEmpty(headMap.get(key))){
                        throw new ExcelAnalysisException("解析excel出错，请传入正确格式的excel");
                    }
                    if (!headMap.get(key).equals(indexNameMap.get(key))){
                        throw new ExcelAnalysisException("解析excel出错，请传入正确格式的excel");
                    }
                }

            } catch (NoSuchFieldException e) {
                e.printStackTrace();
            }
        }
    }

    /**
      * @description: 获取注解里ExcelProperty的value，用作校验excel
      * @param clazz 
      * @throws
      * @return java.util.Map<java.lang.Integer,java.lang.String> 
      * @author zhy
      * @date 2019/12/24 19:21 
      */
    @SuppressWarnings("rawtypes")
    public Map<Integer,String> getIndexNameMap(Class clazz) throws NoSuchFieldException {
        Map<Integer,String> result = new HashMap<>();
        Field field;
        Field[] fields=clazz.getDeclaredFields();
        for (int i = 0; i <fields.length ; i++) {
            field=clazz.getDeclaredField(fields[i].getName());
            field.setAccessible(true);
            ExcelProperty excelProperty=field.getAnnotation(ExcelProperty.class);
            if(excelProperty!=null){
                int index = excelProperty.index();
                String[] values = excelProperty.value();
                StringBuilder value = new StringBuilder();
                for (String v : values) {
                    value.append(v);
                }
                result.put(index,value.toString());
            }
        }
        return result;
    }


}
